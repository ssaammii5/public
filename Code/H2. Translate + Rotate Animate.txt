#include <graphics.h>
#include <iostream>
#include <cmath>
#include <conio.h>
using namespace std;

void drawPoly(int x[], int y[], int n, int ox, int oy, int color) {
    setcolor(color);
    for (int i = 0; i < n; ++i) {
        int j = (i + 1) % n;
        line(ox + x[i], oy - y[i], ox + x[j], oy - y[j]);
    }
}

int main() {
    int gd = DETECT, gm; initgraph(&gd, &gm, "");
    int w = getmaxx(), h = getmaxy(), ox = w/2, oy = h/2;
    int n; cout << "Enter number of vertices: "; cin >> n;
    int x[20], y[20];
    for (int i = 0; i < n; ++i) {
        cout << "Vertex " << i << " (x y) relative to center: ";
        cin >> x[i] >> y[i];
    }
    int tx, ty; cout << "Enter translation vector (tx ty): "; cin >> tx >> ty;
    double targetAngle; cout << "Enter rotation angle (deg): "; cin >> targetAngle;

    // Compute centroid
    double cx=0, cy=0;
    for (int i = 0; i < n; ++i) { cx += x[i]; cy += y[i]; }
    cx /= n; cy /= n;

    const int steps = 60;
    // Phase 1: Translate
    for (int s = 0; s <= steps; ++s) {
        double t = (double)s/steps;
        int txc[20], tyc[20];
        for (int i = 0; i < n; ++i) {
            txc[i] = x[i] + (int)round(tx*t);
            tyc[i] = y[i] + (int)round(ty*t);
        }
        cleardevice();
        drawPoly(x, y, n, ox, oy, WHITE);
        drawPoly(txc, tyc, n, ox, oy, YELLOW);
        delay(50);
    }
    // Cache translated
    int txF[20], tyF[20];
    for (int i = 0; i < n; ++i) {
        txF[i] = x[i] + tx;
        tyF[i] = y[i] + ty;
    }
    // Phase 2: Rotate
    for (int s = 1; s <= steps; ++s) {
        double a = targetAngle * s / steps * M_PI/180.0;
        int rx[20], ry[20];
        for (int i = 0; i < n; ++i) {
            double dx = txF[i]-cx, dy = tyF[i]-cy;
            double nx = dx*cos(a) - dy*sin(a) + cx;
            double ny = dx*sin(a) + dy*cos(a) + cy;
            rx[i] = (int)round(nx); ry[i] = (int)round(ny);
        }
        cleardevice();
        drawPoly(x, y, n, ox, oy, WHITE);
        drawPoly(rx, ry, n, ox, oy, YELLOW);
        delay(50);
    }
    getch(); closegraph(); return 0;
}
